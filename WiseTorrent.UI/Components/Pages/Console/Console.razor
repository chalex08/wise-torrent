@page "/console"
@using System.Text.RegularExpressions
@using WiseTorrent.Utilities.Interfaces
@using WiseTorrent.Utilities.Types
@inject ILogService LogService
@inject IJSRuntime JS

<PageTitle>Console</PageTitle>

<div class="console-page">
	<h1 id="consoleHeader">Console</h1>

	<main class="console-body">
		<div id="logViewer" class="log-viewer" @ref="logContainer">
			@foreach (var entry in logs)
			{
				<div id="message" style="margin: 0; padding: 0; line-height: 1.2; color:@GetColor(entry.Level);">
					<b>[@entry.Timestamp] [@entry.Level] [@entry.ClassName]</b> @entry.Message
				</div>
			}
		</div>
	</main>

	<div style="padding: 0.5rem 1rem;">
		<label>
			<input type="checkbox" @bind="forcePinToBottom" />
			Stay pinned to bottom
		</label>
	</div>
</div>

<style>
	.console-page {
	display: flex;
	flex-direction: column;
	height: 100%;
	}

	.console-body {
	flex: 1;
	overflow: hidden;
	display: flex;
	flex-direction: column;
	}

	.log-viewer {
	flex: 1;
	overflow-y: auto;
	font-family: monospace;
	white-space: pre-wrap;
	padding: 1rem;
	}
</style>

<script>
	window.logViewerState = {
	isPinnedToBottom: true
	};

	window.trackScrollPosition = function (element) {
	if (!element) return;

	const updateScrollState = () => {
	const distance = element.scrollHeight - element.scrollTop - element.clientHeight;
	const isNearBottom = distance <= element.clientHeight * 0.1;

	if (!isNearBottom) {
	window.logViewerState.isPinnedToBottom = false;
	}
	};

	element.addEventListener("scroll", updateScrollState);
	updateScrollState();
	};

	window.getScrollState = function () {
	return window.logViewerState.isPinnedToBottom;
	};

	window.scrollToEnd = function (element) {
	if (element) {
	element.scrollTo({ top: element.scrollHeight, behavior: 'smooth' });
	}
	};

	window.adjustLogViewerHeight = function (fontSize = "0.8rem") {
	const viewer = document.getElementById("logViewer");
	const header = document.getElementById("consoleHeader");

	if (viewer && header) {
	const windowHeight = window.innerHeight;
	const headerHeight = header.offsetHeight;
	const maxHeight = (windowHeight - headerHeight) * 0.85;
	viewer.style.maxHeight = maxHeight + "px";
	viewer.style.fontSize = fontSize;
	}
	};

	window.addEventListener("resize", () => {
	window.adjustLogViewerHeight();
	});

	window.untrackScrollPosition = function (element) {
	if (!element || !element._scrollHandler) return;
	element.removeEventListener("scroll", element._scrollHandler);
	delete element._scrollHandler;
	};
</script>

@code {
	private bool forcePinToBottom = false;
	private double ProgressPercent = 0;
	private IReadOnlyList<LogEntry> logs = Array.Empty<LogEntry>();
	private ElementReference logContainer;
	private bool shouldScroll = false;
	private bool _subscribed = false;
	private DateTime lastRefresh = DateTime.UtcNow;
	private int pendingLogCount = 0;
	private string pattern = @"Torrent is (\d+\.\d+)% complete";

	private void HandleLog(LogEntry entry)
	{
		Match match = Regex.Match(entry.Message, pattern);
		if (entry.Level == LogLevel.Warn && match.Success && double.TryParse(match.Groups[1].Value, out double completion))
		{
			ProgressPercent = completion;
		}

		var now = DateTime.UtcNow;
		if (++pendingLogCount >= SessionConfig.LogRefreshThreshold || now - lastRefresh >= SessionConfig.LogRefreshIntervalSeconds)
		{
			logs = LogService.GetLogs();
			pendingLogCount = 0;
			lastRefresh = now;
			shouldScroll = true;
			InvokeAsync(StateHasChanged);
		}
	}

	protected override void OnInitialized()
	{
		if (!_subscribed)
		{
			LogService.Subscribe(HandleLog);
			_subscribed = true;
		}

		logs = LogService.GetLogs();
	}
	
	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			await JS.InvokeVoidAsync("adjustLogViewerHeight");
			await JS.InvokeVoidAsync("trackScrollPosition", logContainer, 2);
			await JS.InvokeVoidAsync("scrollToEnd", logContainer);
		}

		if (shouldScroll)
		{
			shouldScroll = false;
			bool shouldScrollToBottom = forcePinToBottom || await JS.InvokeAsync<bool>("getScrollState");
			if (shouldScrollToBottom)
			{
				await JS.InvokeVoidAsync("scrollToEnd", logContainer);
			}
		}
	}

	private string GetColor(LogLevel level) => level switch
	{
		LogLevel.Info => "black",
		LogLevel.Warn => "orange",
		LogLevel.Error => "red",
		_ => "gray"
	};

	public async void Dispose()
	{
		await JS.InvokeVoidAsync("untrackScrollPosition", logContainer);
		LogService.Unsubscribe(HandleLog);
	}
}